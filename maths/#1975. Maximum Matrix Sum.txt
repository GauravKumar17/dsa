You are given an n x n integer matrix. You can do the following operation any number of times:

Choose any two adjacent elements of matrix and multiply each of them by -1.
Two elements are considered adjacent if and only if they share a border.

Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.

 

Example 1:


Input: matrix = [[1,-1],[-1,1]]
Output: 4
Explanation: We can follow the following steps to reach sum equals 4:
- Multiply the 2 elements in the first row by -1.
- Multiply the 2 elements in the first column by -1.
Example 2:


Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
Output: 16
Explanation: We can follow the following step to reach sum equals 16:
- Multiply the 2 last elements in the second row by -1.
 

Constraints:

n == matrix.length == matrix[i].length
2 <= n <= 250
-105 <= matrix[i][j] <= 105

Solution(#1) => t.c =O(n^2);

Intution:
Find the absolute sum of all the numbers in the matrix
Find the absolute value of the smallest number in the matrix
Count of negative numbers in the matrix
If count of negatives is even, then all elements can be made +ve by performing the operation, so just return sum
If count of negatives is odd, then we can make the smallest number in the matrix as -ve and then return sum


class Solution {
public:
    long long maxMatrixSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        long long sum = 0,count=0;
        int minabs=INT_MAX;
        for(int i = 0 ;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[i][j] < 0){
                    count++;
                }
                minabs = min(minabs,abs(matrix[i][j]));
                
                sum+=abs(matrix[i][j]);
            }
        }
        if(count %2 == 0){
            return sum;
        }
        else{
            
            return sum- 2LL*minabs; 
        }
        
    }
};