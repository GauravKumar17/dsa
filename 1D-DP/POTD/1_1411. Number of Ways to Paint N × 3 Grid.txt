You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).

Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7.

 

Example 1:


Input: n = 1
Output: 12
Explanation: There are 12 possible way to paint the grid as shown.
Example 2:

Input: n = 5000
Output: 30228214
 

Constraints:

n == grid.length
1 <= n <= 5000

Solution(#1 => Memoization)  Time complexity: O(n) Space complexity: O(n)

class Solution {
private:
    vector<string>options={"ryr","yry","gry","ryg","yrg","grg","rgr","ygr","gyr","rgy","ygy","gyg"};
    int M = 1e9 + 7;

    vector<vector<int>>dp;

    int solve(int n, int prev){
        if(n==0){
            return 1;
        }
        if(dp[n][prev] != -1){
            return dp[n][prev];
        }
        int res = 0;
        string color = options[prev];

        for(int curr=0; curr<12; curr++){
            if(curr == prev){
                continue;
            }
            
            string newColor = options[curr];
            bool conflict = false;
            for(int col=0;col<3;col++){
                if(color[col] == newColor[col]){
                    conflict = true;
                    break;
                }
            }
            if(!conflict){
                res  = (res+solve(n-1,curr))%M;
            }
        }
        return dp[n][prev] = res;
    }
public:
    int numOfWays(int n) {
        dp.resize(n,vector<int>(13,-1));
        int res = 0;
        for(int i=0;i<12;i++){
            res = (res + solve(n-1,i))%M;
        }

        return res;

    }
};