Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

 

Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
Example 2:

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300



Solution(#1) => BFS 
(t.c => O(m*n))
[since, vis array â†’ O(m Ã— n) and Queue (worst case all land) â†’ O(m Ã— n)]

class Solution {
public:
    void bfs(vector<vector<char>>& grid,vector<vector<int>>& vis,int i,int j,int m, int n){
        vis[i][j] = 1;
        queue<pair<int,int>>q;
        q.push({i,j});
        vector<pair<int,int>>directions = {{1,0},{-1,0},{0,1},{0,-1}};
        while(!q.empty()){
            int a = q.front().first;
            int b = q.front().second;
            q.pop();

            for(auto &dir:directions){
                int c = a+dir.first;
                int d = b+dir.second;
                if(c>=0 && c<m && d>=0 && d<n && grid[c][d] == '1' && vis[c][d]!=1){
                    q.push({c,d});
                    vis[c][d] = 1;

                }
            }

        }
        
    }
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>>vis(m,vector<int>(n ,0));
        int count = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(!vis[i][j] && grid[i][j] == '1'){
                    count++;
                    bfs(grid,vis,i,j,m,n);
                }
            }
        }
        return count;

        
    }
};

Solution(#2)=> DFS (t.c=> O(m*n))

class Solution {
public:
    void dfs(vector<vector<char>>& grid, vector<vector<int>>& vis, int i, int j,
             int m, int n) {
        vis[i][j] = 1;

        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        for (auto& dir : directions) {
            int c = i + dir.first;
            int d = j + dir.second;
            if (c >= 0 && c < m && d >= 0 && d < n && grid[c][d] == '1' &&
                vis[c][d] != 1) {

                dfs(grid, vis, c, d, m, n);
            }
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> vis(m, vector<int>(n, 0));
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!vis[i][j] && grid[i][j] == '1') {
                    count++;
                    dfs(grid, vis, i, j, m, n);
                }
            }
        }
        return count;
    }
};


Explaination Of time complexity:


1ï¸âƒ£ What your brain is doing (and why it feels like Ã—)

You see this:

for (i = 0 to m)
  for (j = 0 to n)
    bfs(...)


And inside BFS you see:

while (!q.empty())


So your brain says:

â€œNested loops â†’ multiply â†’ O(mn) Ã— O(mn)â€

This would be correct IF BFS ran fully for every cell.

But it does not.



2ï¸âƒ£ The ONE rule that breaks the multiplication

Once a cell is visited, it is NEVER processed again.

This single fact changes everything.



3ï¸âƒ£ Letâ€™s simulate worst case (ALL land)

Assume:

Grid = m Ã— n

Every cell = '1'

Step A: Outer loops
for all cells:
    if not visited:
        bfs()


First cell (0,0) â†’ not visited â†’ BFS starts

BFS will visit EVERY cell

All cells become visited

Now:

For (0,1), (0,2), ..., (m-1,n-1)

vis[i][j] == true

BFS is NOT called again

ðŸ‘‰ BFS runs ONCE, not mÃ—n times.



4ï¸âƒ£ What does BFS do internally?

Inside BFS:

while (!q.empty()) {
    pop one cell
    check 8 neighbors
}


Each cell:

Is pushed into queue once

Is popped once

Checks 8 neighbors (constant)

So total BFS work:

(m Ã— n) Ã— 8  â†’ O(m Ã— n)



5ï¸âƒ£ What if there are many islands?

Worst case:

1 0 1 0 1
0 0 0 0 0
1 0 1 0 1


BFS runs multiple times

BUT each BFS covers disjoint cells

No cell is ever processed twice

So total work is still:

(sum of sizes of all islands) = m Ã— n



6ï¸âƒ£ Why multiplication DOES NOT apply (key insight)

Multiplication applies only when:

â€œFor every iteration of loop A, loop B runs fully.â€

Here:

BFS does not run fully for each (i, j)

It runs only for unvisited cells

And collectively, all BFS calls cover each cell once

So we ADD the work, not multiply it.



7ï¸âƒ£ The money analogy (this usually makes it click)

Imagine:

You have mÃ—n boxes

Each box has $1

BFS means â€œpick up money from connected boxesâ€

You never pick money from the same box twice.

So total money collected:

$1 + $1 + ... = m Ã— n dollars


Not:

(m Ã— n) Ã— (m Ã— n)



ðŸ”‘ ONE sentence to memorize (this is the key)

BFS is not O((mn)Â²) because each cell enters the queue once and is processed once â€” BFS work is distributed, not repeated.