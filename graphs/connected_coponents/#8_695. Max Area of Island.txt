You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value 1 in the island.

Return the maximum area of an island in grid. If there is no island, return 0.

 

Example 1:


Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
Example 2:

Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
grid[i][j] is either 0 or 1.


Solution(#1)=>[BFS] t.c=> O(m*n)

class Solution {
public:
    void bfs(vector<vector<int>>& grid,vector<vector<int>>& vis,int &maxsum ,int i,int j,int m,int n){

        queue<pair<int,int>>q;
        q.push({i,j});
        vector<pair<int,int>>directions = {{1,0},{-1,0},{0,1},{0,-1}};
        int sum = 1;
        while(!q.empty()){
            int x = q.front().first;
            int y = q.front().second;

            q.pop();
            vis[x][y] = 1;
            for(auto &dir:directions){
                int a = x+dir.first;
                int b = y+dir.second;
                if(a>=0 && a<m && b>=0 && b<n && grid[a][b] == 1 && !vis[a][b]){
                    vis[a][b] = 1;
                    sum++;
                    q.push({a,b});
                    
                }
            }

        }
        maxsum = max(maxsum,sum);

    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int maxsum = INT_MIN;

        vector<vector<int>>vis(m,vector<int>(n,0));
        int key = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] == 1 && !vis[i][j]){
                    key = 1;
                    bfs(grid,vis,maxsum,i,j,m,n);
                }
            }
        }
        if(!key){
            return 0;
        }
        
        return maxsum;
    }
};