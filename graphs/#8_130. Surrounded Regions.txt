You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded:

Connect: A cell is connected to adjacent cells horizontally or vertically.
Region: To form a region connect every 'O' cell.
Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board.
To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.

 

Example 1:

Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]

Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]

Explanation:


In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.

Example 2:

Input: board = [["X"]]

Output: [["X"]]

 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is 'X' or 'O'.


Intution:
1. go through corner rows and column, and apply dfs to the 'O', so that all the Os are identified which are connected with boundary
2. mark these binary connected Os to 1 in visited matrix
3. iterate through whole matrix and change only those Os to x ahich are not marked visited in vis matrix.


Solution(#1)=> dfs
class Solution {
public: 
    void dfs(int i, int j,vector<vector<char>>& board,vector<vector<int>>& vis,int m, int n){
        vis[i][j] = 1;
        vector<pair<int,int>>directions = {{1,0},{-1,0},{0,1},{0,-1}};

        for(auto &dir:directions){
            int a = i + dir.first;
            int b = j + dir.second;
            if(a>=0 && b>=0 && a<m && b<n && board[a][b] == 'O' && vis[a][b] != 1){
                vis[a][b] = 1;
                dfs(a,b,board,vis,m,n);

            }
        }
    }

    void solve(vector<vector<char>>& board) {

        if(board.empty() || board[0].empty()) return;

        int m = board.size();
        int n = board[0].size();
        vector<vector<int>>vis(m,vector<int>(n,0));

        //rows
        for(int j=0;j<n;j++){
            //0th row
            if(board[0][j] == 'O' && vis[0][j] != 1){
                dfs(0,j,board,vis,m,n);
            }

            //last row
            if(board[m-1][j] == 'O' && vis[m-1][j] != 1){
                dfs(m-1,j,board,vis,m,n);
            }
        }

        for(int j=0;j<m;j++){
            
            //0th col

            if(board[j][0] == 'O' && vis[j][0] != 1){
                dfs(j,0,board,vis,m,n);
            }

            //last col
            if(board[j][n-1] == 'O' && vis[j][n-1] != 1){
                dfs(j,n-1,board,vis,m,n);
            }
        }


        // finally change Os to X which are not connected to corner Os
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j] == 'O' && vis[i][j] != 1){
                    board[i][j] = 'X';
                }
            }
        }
    }
};


Solution=> bfs

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int rows = board.size(), cols = board[0].size();
        queue<pair<int, int>> q;
        for(int i = 0; i < rows; i++){
            if(board[i][0] == 'O'){
                board[i][0] = 'S';
                q.push({i, 0});
            }
            if(board[i][cols - 1] == 'O'){
                board[i][cols - 1] = 'S';
                q.push({i, cols - 1});
            }
        }
        for(int i = 0; i < cols; i++){
            if(board[0][i] == 'O'){
                board[0][i] = 'S';
                q.push({0,i});
            }
            if(board[rows - 1][i] == 'O'){
                board[rows - 1][i] = 'S';
                q.push({rows - 1, i});
            }
        }

        vector<int> drow = {0, -1, 0, 1};
        vector<int> dcol = {-1, 0, 1, 0};

        while(!q.empty()){
            int row = q.front().first;
            int col = q.front().second;
            q.pop();

            for(int i = 0; i < 4; i++){
                int nrow = row + drow[i];
                int ncol = col + dcol[i];
                if(nrow >= 0 && nrow < rows &&  ncol >= 0 && ncol < cols && board[nrow][ncol] == 'O'){
                    board[nrow][ncol] = 'S';
                    q.push({nrow, ncol});
                }
            }
        }

        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                if(board[i][j] == 'O')board[i][j] = 'X';
                else if(board[i][j] == 'S')board[i][j] = 'O';
            }
        }
    }
};