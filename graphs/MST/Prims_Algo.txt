Given a weighted, undirected, and connected graph with V vertices and E edges, your task is to find the sum of the weights of the edges in the Minimum Spanning Tree (MST) of the graph. The graph is provided as a list of edges, where each edge is represented as [u, v, w], indicating an edge between vertex u and vertex v with edge weight w.

Input: V = 3, E = 3, Edges = [[0, 1, 5], [1, 2, 3], [0, 2, 1]]
 
Output: 4
Explanation:

The Spanning Tree resulting in a weight
of 4 is shown above.
Input: V = 2, E = 1, Edges = [[0 1 5]]

 

Output: 5 
Explanation: Only one Spanning Tree is possible which has a weight of 5.
Constraints:
2 ≤ V ≤ 1000
V-1 ≤ E ≤ (V*(V-1))/2
1 ≤ w ≤ 1000
The graph is connected and doesn't contain self-loops & multiple edges.


Solution(#1)=> Prim's Algorithm [t.c=> O(E log V)] --> Dry run in copy

class Solution {
  public:
    int spanningTree(int V, vector<vector<int>>& edges) {
        // code here
        vector<vector<pair<int,int>>>adj(V);
        
        for(int i=0;i<edges.size();i++){
            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});
            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});
        }
        
        vector<int>vis(V,0);
        vector<pair<int,int>>mst;
        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>pq;
        pq.push({0,0,-1}); //wt,node,parent

        int sum = 0;
        
        while(!pq.empty()){
            auto[wt,node,parent] = pq.top();
            pq.pop();
            
            if(vis[node]) continue;
            
            vis[node] = 1;
            sum += wt;
            mst.push_back({node,parent});
            
            for(auto &x: adj[node]){
                int newNode = x.first;
                int nodeWt = x.second;
                
                if(!vis[newNode]){
                    pq.push({nodeWt,newNode,node});
                }
            }
        }
        
        return sum;
        
    }
};