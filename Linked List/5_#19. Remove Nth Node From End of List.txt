Given the head of a linked list, remove the nth node from the end of the list and return its head.

Example 1:


Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
Example 2:

Input: head = [1], n = 1
Output: []
Example 3:

Input: head = [1,2], n = 1
Output: [1]
 

Constraints:

The number of nodes in the list is sz.
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz
 

Follow up: Could you do this in one pass?

solution(two pass)=> T.c => O(n)

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        

        ListNode dummy;
        dummy->next = head;

        ListNode* temp = head;
        int len = 1;

        while(temp->next!=NULL){
            temp = temp->next;
            len++;
        }

        temp = head;
        ListNode* prev = dummy;

        for(int i=0;i<len-n;++i){
            prev = temp;
            temp = temp->next;
        }

        prev->next = temp->next;
        temp->next = NULL;

        
        return dummy->next;
        
    }
};


solution(one pass)=>TWO POINTERS T.c => O(n)

Intutuion:

Use two pointers so that the gap between them is exactly n.
Move the right pointer n steps ahead first.
Then move both pointers together.
When the right pointer reaches the end, the left pointer will be just before the node we must remove.
This avoids counting the entire list and removes the target in one pass.

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        

        ListNode* dummy = new ListNode(0);
        dummy->next = head;

        ListNode* left = dummy;
        ListNode* right= head;
        
        while(n>0){
            right = right->next;
            n--;
        }

        while(right){
            right = right->next;
            left = left->next;
        }

        left->next = left->next->next;
        return dummy->next;
        
    }
};

