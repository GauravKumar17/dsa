Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and using only constant extra space.

 

Example 1:

Input: nums = [1,3,4,2,2]
Output: 2
Example 2:

Input: nums = [3,1,3,4,2]
Output: 3
Example 3:

Input: nums = [3,3,3,3,3]
Output: 3
 

Constraints:

1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.
 

Follow up:

How can we prove that at least one duplicate number must exist in nums?
Can you solve the problem in linear runtime complexity?



Note:- Multiple approaches can be their to solve this problem 
ex:- 1. using hashmap => will take extra memory
    2. sorting the array and then checking i and i+1 are same or not => O(nlogn + n) sol

Solution(#1)=> Negative indexing (O(n))

Intution:
We can use the given input array itself as a hash set without creating a new one.
This can be achieved by marking the positions (0-indexed) corresponding to the elements that have already been encountered

We iterate through the array using index i. For each element, we use its absolute value to find the corresponding index and mark that position as negative: nums[abs(nums[i]) - 1] *= -1.
 Taking absolute value ensures we work with the original value even if it’s already negated.

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int len = nums.size();
        
        for(int i=0;i<len;i++){
            if(nums[abs(nums[i])-1] < 0){
                return abs(nums[i]);
            }
            else{
                nums[abs(nums[i])-1] *= -1;
            }
        }

    return 0;
        
        
    }
};

Solution(#2) => fast and slow pointers (t.c => O(n))

Intuition
Treat the array like a linked list, where each index points to the next index given by its value.
Because one number is duplicated, two indices will point into the same chain, creating a cycle — exactly like a linked list with a loop.

Using Floyd’s Fast & Slow Pointer technique:

The slow pointer moves one step at a time.
The fast pointer moves two steps at a time.
If there’s a cycle, they will eventually meet.
Once they meet, we start a new pointer from the beginning:

Move both pointers one step at a time.
The point where they meet again is the duplicate number (the entry point of the cycle).

https://youtu.be/wjYnzkAhcNk

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0;
        int fast = 0;

        while(true){
            slow  = nums[slow];  // considering linkedlist 
            fast = nums[nums[fast]];
            if(slow==fast){
                break;
            }
        }
        int slow2 = 0;

        while(true){
            slow = nums[slow];
            slow2 = nums[slow2];

            if(slow == slow2){
                return slow;
            }
        }
        
    }
};

