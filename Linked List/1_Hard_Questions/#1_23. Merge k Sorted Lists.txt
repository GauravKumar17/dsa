You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

 

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted linked list:
1->1->2->3->4->4->5->6
Example 2:

Input: lists = []
Output: []
Example 3:

Input: lists = [[]]
Output: []
 

Constraints:

k == lists.length
0 <= k <= 104
0 <= lists[i].length <= 500
-104 <= lists[i][j] <= 104
lists[i] is sorted in ascending order.
The sum of lists[i].length will not exceed 104.

Solution(#1) => Uisng min-heap and comparator


struct compare {
    bool operator()(ListNode* a, ListNode* b) { 
        return a->val > b->val;
     }
};

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, compare> pq;  //note- 3rd argument(comparator) of pq is either struct or class (ex;- greater<int> was struct defined by c++)

        // push head of each limked list in the pq
        for (auto& node : lists) {
            if (node) {
                pq.push(node);
            }
        }
        // (heap allocation slower and remains on heap until delete is called)
        // ListNode* dummy = new ListNode(0);
        // ListNode* tail = dummy;

        // (object is created on stack ,faster and automatically deleted)
        ListNode dummy(0);
        ListNode* tail = &dummy;

        while (!pq.empty()) {
            ListNode* smallest = pq.top();
            pq.pop();

            tail->next = smallest;
            tail = tail->next;

            if (smallest->next) {
                pq.push(smallest->next);
            }
        }

        return dummy.next; // use dummy->next if pointer points to heap memory
    }
};