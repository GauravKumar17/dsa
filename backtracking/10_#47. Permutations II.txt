Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

 

Example 1:

Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
Example 2:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 

Constraints:

1 <= nums.length <= 8
-10 <= nums[i] <= 10


Solution(#1) Backtracking (t.c=> O(n! * n))

class Solution {
    vector<vector<int>> res;
    
    void solve(vector<int> nums, vector<int>& temp,
               unordered_map<int, int>& mp) {
        if (temp.size() == nums.size()) {
            res.push_back(temp);
            return;
        }
        unordered_set<int>used; //used should be at recursion level and not global. it says “At THIS recursion level, which values have I already tried?”
        
        for (int i = 0; i < nums.size(); i++) {
            if (mp[nums[i]] != 0 && used.find(nums[i]) == used.end()) {
                
                mp[nums[i]]--;
                used.insert(nums[i]);
                temp.push_back(nums[i]);

                solve(nums, temp, mp);

                temp.pop_back();
                mp[nums[i]]++;
            }
        }
    }

public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<int> temp;
        unordered_map<int, int> mp;
        for (int x : nums) {
            mp[x]++;
        }
        solve(nums, temp, mp);
        return res;
    }
};