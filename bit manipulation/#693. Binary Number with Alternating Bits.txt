Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

 

Example 1:

Input: n = 5
Output: true
Explanation: The binary representation of 5 is: 101
Example 2:

Input: n = 7
Output: false
Explanation: The binary representation of 7 is: 111.
Example 3:

Input: n = 11
Output: false
Explanation: The binary representation of 11 is: 1011.
 

Constraints:

1 <= n <= 231 - 1
 
Solution(#1) => T.c= O(n), space = O(1)

class Solution {
public:
    bool hasAlternatingBits(int n) {
        vector<int>v;
        while(n){
            int rem = n%2;
            v.push_back(rem);
            n  = n/2;

        }

        for(int i=1;i<v.size();i++){
            if(v[i] == !v[i-1]){
                continue;
            }

            return false;
        }

        return true;
    }
};

Solution(#2) = >T.c= O(1) space = O(1);

class Solution {
public:
    bool hasAlternatingBits(int n) {

        int firstBit;
        if (n % 2 == 0) {  // if even set firstBit = 1 or vice-versa
            firstBit = 1;
        } else {
            firstBit = 0;
        }
        while (n) {
            int rem = n % 2;
            if (rem != !firstBit) {
                return false;
            }
            firstBit = rem;
            n = n / 2;
        }

        return true;
    }
};