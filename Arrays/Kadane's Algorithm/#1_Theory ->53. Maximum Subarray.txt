Given an integer array nums, find the subarray with the largest sum, 
and return its sum.
Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
Example 2:

Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
Example 3:

Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104


//solution-

1. Brute Force (O(n^2));

int bruteForce(vector<int>& nums) {
    int maxSum = nums[0];

    for (int i = 0; i < nums.size(); i++) {
        int curSum = 0;
        for (int j = i; j < nums.size(); j++) {
            curSum += nums[j];
            maxSum = max(maxSum, curSum);
        }
    }
    return maxSum;
}

2. optimal (Kadane,s algo => O(n))

Approach=>
Since we are looking for the largest sum, it is a good idea to avoid negative numbers because we know that contradicts what the question is asking for. Negative numbers will only make our sum smaller.

But sometimes we may need to include a negative number to get the surrounding positive numbers.

For example, the array [6, -2, 7] has a maximum sum of 11. If we exclude the -2, we can't include both 6 and 7.
But that's not always the case. If we have [1, -3, 7], the maximum sum is 7. Including the -3 isn't worth it just to get the 1.
The pattern is that if we ever have a negative subarray sum, we should discard it and start a new subarray. This is because we know that the sum will only get smaller if we include it.

Kadane's algorithm runs one loop.
We keep track of the curSum by adding the current element to it.
Before we add the current element, we check if the curSum is negative. If it is, we reset it to zero.
We initialize the maxSum to the first element in the array. This is technically a subarray of size 1. (We could have initialized it to any other element in the array.)
We update the maxSum by taking the maximum of the current sum and the maximum sum so far.

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int maxSum = INT_MIN;
        int currSum = 0;

        for(int i=0;i<n;i++){
            if(currSum<0){  // if currsum = -ve hange it to zero
                currSum = 0;
            }
            currSum+=nums[i];
            maxSum = max(maxSum,currSum);

        }
        return maxSum;
        
    }
};