146. LRU Cache
Attempted
Medium
Topics
premium lock icon
Companies
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in O(1) average time complexity.

 

Example 1:

Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
 

Constraints:

1 <= capacity <= 3000
0 <= key <= 104
0 <= value <= 105
At most 2 * 105 calls will be made to get and put.


solution:-
1.( Brute-force) each operation takes O(n) time. [TLE (22/24 passed)]
class LRUCache {
private:
    vector<pair<int,int>>cache; // 1d vector carrying values in pairs,currently empty
    int capacity;

public:
    LRUCache(int capacity) {
        this->capacity = capacity;
    }
    
    //O(n)
    int get(int key) {
        for(int i=0;i<cache.size();i++){
            if(cache[i].first == key){ // if the ley exsist in the catch
                int value = cache[i].second; // store the value of the key
                cache.erase(cache.begin()+i); // erarse the original pair
                cache.push_back({key,value}); // put the pair at MRU position i.e at last
                return value;
            }
            
        }
        return -1;
        
    }

    //O(n)
    void put(int key, int value) {
        //checks if the pair already exists in the vector
        for(int i=0;i<cache.size();i++){
            if(cache[i].first == key){ // if already exist then remove it.
                cache.erase(cache.begin()+i);
                cache.push_back({key,value}); //after removing put new updated key-value to last 
                return;     
            }
        }
        // if it did not exsist previously and new value is to be added but size of vector is full
        if(cache.size()==capacity){
            //remove the pair at index 0 to make space for new pair
            cache.erase(cache.begin()+ 0);
        }


        // if it did not previously exist add a new key-value to the last
        cache.push_back({key,value});
        
    }
};


2.(Approach 2 => using hashmap to store keys and doubly linkedlist to store values) => O(1)


Intuition
We want all operations to be O(1) while still following LRU (Least Recently Used) rules.

To do that, we combine:

Hash Map → quickly find a node by its key in O(1).
Doubly Linked List → quickly move nodes to the most recently used position and remove the least recently used node from the other end in O(1).
We keep:

The most recently used node near the right side.
The least recently used node near the left side.
Whenever we:

Get a key: move that node to the right (most recently used).
Put a key:
If it exists: update value and move it to the right.
If it’s new:
If at capacity: remove the leftmost real node (LRU).
Insert the new node at the right.


class Node{
public:
    int key;
    int val;
    Node *next;
    Node *prev;

    Node(int key, int val){
        this->key = key;
        this->val = val;
        this->next =  NULL;
        this->prev = NULL;
    }
};


class LRUCache {
private:
    unordered_map<int,Node*>cache;  //this map contains keys->LRU Keys, Values->pointer to a ll which contain LRU key and LRU value both
    int capacity;
    Node* left;     // here , so that universally acessible by all members
    Node* right;

    void insert(Node *node){
        Node* back = right->prev;
        back->next = node;
        node->prev = back;
        node->next = right;
        right->prev=  node;

    }

    void remove(Node *node){
        node->prev->next = node->next;
        node->next->prev = node->prev;
        node->next = NULL;
        node->prev = NULL;

    }
    
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
        left = new Node(0,0);  // initializing left node. (whole l.l is generated between these two nodes left &right)
        right = new Node(0,0); //initializing right node
        left->next = right;
        right->prev = left;

    }
    
    int get(int key) {
        if(cache.find(key)!=cache.end()){
            remove(cache[key]); // cache[key]-> store pointer to ll as a  map value
            insert(cache[key]);
            
            return cache[key]->val;
        }
        return -1;   
    }
    
    void put(int key, int value) {
        if(cache.find(key)!=cache.end()){
            remove(cache[key]);
        }
        Node *newnode = new Node(key,value);
        cache[key]=newnode; // storing value of map to node of a ll
        insert(newnode);

        if(cache.size()>capacity){
            Node *temp = left->next; 
            remove(temp);
            cache.erase(temp->key);
            delete(temp);
        }
        
    }
};

