Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

 

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

Solutions:

1.Brute Force (Using unordered_set) t.c => O(n)

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int>result;
        unordered_set<int>us;
        unordered_set<int>us2;

        

        for(int i=0;i<nums1.size();i++){   // insertion in unordered_set takes O(1) time at best and avg case
            us.insert(nums1[i]);  
        }
        for(int i=0;i<nums2.size();i++){  //o(1)
            us2.insert(nums2[i]);  
        }

        int len1 = us.size();
        int len2 = us2.size();

        if(len1>len2){
            for(int x: us2){    // o(n)
                if(us.count(x)==1){   // count() checks if element is present in the set or not and retuns 1 if present else 0 and takes o(1) time
                    result.push_back(x);
                }
            }
        }
        else{
            for(int x: us){             //(o(n))
                if(us2.count(x)==1){
                    result.push_back(x);
                }
            }
        }

        return result;
        
    }
};


#2 more optimized and cleaner than prev code. T.C=>(O(n)) 

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int>us(nums1.begin(),nums1.end());   // copies vector to the set
        unordered_set<int>result;

        for(int x: nums2){
            if(us.count(x)){
                result.insert(x);
            }
        }

        

        return vector<int>(result.begin(),result.end());  // returns set as a vector
        
    }
};