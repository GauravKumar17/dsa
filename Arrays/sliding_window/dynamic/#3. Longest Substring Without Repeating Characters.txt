Given a string s, find the length of the longest substring without duplicate characters.

 

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
 

Constraints:

0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols and spaces.


Solution(#1 => BruteForce) T.c(O(n*m))

Note- use set or vector instead of string to store the substring for better performance

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = 0,l=0;
        string str="";
        for(int r=0;r<s.length();r++){
            for(int l=r;l<s.size();l++){
            char x = s[l];
            if(str.find(x)==string::npos){
                str.push_back(x);
                len = max(len,(int)str.size());

            }
            else{
                str.clear();
                break;

            }


        }
        }
        return len;
        
    }
};

Solution(#2) => using sliding window (t.c=>O(n), s.c=>O(m))

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = 0,l=0;
        unordered_set<char>str;
        for(int r=0;r<s.length();r++){
            char x = s[r];
            while(str.find(x)!=str.end()){
                str.erase(s[l]);
                l++;
            }
            str.insert(x);
            len = max(len,r-l+1);
        }
        
        return len;
        
    }
};

Solution(#3) => 3. Sliding Window (Optimal)

Intuition
Instead of removing characters one by one when we see a repeat, we can jump the left pointer directly to the correct position.
We keep a map that stores the last index where each character appeared.
When a character repeats, the earliest valid starting point moves to one position after its previous occurrence.
This lets us adjust the window in one step and always keep it valid, making the approach fast and clean.

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> mp;
        int l = 0, res = 0;

        for (int r = 0; r < s.size(); r++) {
            if (mp.find(s[r]) != mp.end()) {
                l = max(mp[s[r]] + 1, l);
            }
            mp[s[r]] = r;
            res = max(res, r - l + 1);
        }
        return res;
    }
};


