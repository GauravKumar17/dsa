Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.

A grid is said to be valid if all the cells above the main diagonal are zeros.

Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.

The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).

 

Example 1:


Input: grid = [[0,0,1],[1,1,0],[1,0,0]]
Output: 3
Example 2:


Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
Output: -1
Explanation: All rows are similar, swaps have no effect on the grid.
Example 3:


Input: grid = [[1,0,0],[1,1,0],[1,1,1]]
Output: 0
 

Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
grid[i][j] is either 0 or 1

Solution(#1) => t.c = >O(n^2)

class Solution {
public:
    int minSwaps(vector<vector<int>>& grid) {
        int m = grid.size();
        vector<int> trailingZeroes(m);
        for (int i = 0; i < m; i++) {
            int oneCount = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (grid[i][j] == 1) {
                    break;
                }
                oneCount++;
            }
            trailingZeroes[i] = oneCount;
        }
        int swaps = 0;

        for (int i = 0; i < m; i++) {
            int reqZeroes = m - i - 1;
            int j = i;

            while (j < m && trailingZeroes[j] < reqZeroes) {
                j++;
            }
            if (j == m)
                return -1;

            while (j > i) {
                swap(trailingZeroes[j], trailingZeroes[j - 1]);
                swaps++;
                j--;
            }
        }

        return swaps;
    }
};