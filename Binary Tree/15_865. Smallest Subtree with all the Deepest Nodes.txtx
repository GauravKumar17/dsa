Given the root of a binary tree, the depth of each node is the shortest distance to the root.

Return the smallest subtree such that it contains all the deepest nodes in the original tree.

A node is called the deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.

 

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
Example 2:

Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree.
Example 3:

Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
 

Constraints:

The number of nodes in the tree will be in the range [1, 500].
0 <= Node.val <= 500
The values of the nodes in the tree are unique.


Solution(#1) => t.c(O(n^2))

Intution:

For every node:

Compute height of left subtree

Compute height of right subtree

Rules:

If left height == right height → this node is the answer

If left height > right height → answer lies in left subtree

If right height > left height → answer lies in right subtree

This works because:

The deepest nodes must lie in the deeper subtree(s)




class Solution {
public:
    int height(TreeNode* root){
        if(!root){
            return 0;
        }

        return 1+max(height(root->left),height(root->right));
        
    }
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        if(!root || (!root->left && !root->right)){
            return root;
        }
        int h1 = height(root->left);
        int h2 = height(root->right);

        if(h1 == h2){
            return root;
        }
        else if(h1>h2){
            return subtreeWithAllDeepest(root->left);

        }
        else{
            return subtreeWithAllDeepest(root->right);
        }

    
    }
};

Solution(#2 T.c (o(n))) [optimized height call]

class Solution {
public:
    unordered_map<TreeNode*,int>mp;
    int height(TreeNode* root){
        if(!root){
            return 0;
        }

        int depth =  1+max(height(root->left ),height(root->right));
        mp[root] = depth;
        return depth; 
    }
    TreeNode* dfs(TreeNode* root){
        int h1 = mp[root->left];
        int h2 = mp[root->right];

        if(h1 == h2){
            return root;
        }
        else if(h1>h2){
            return dfs(root->left);

        }
        else{
            return dfs(root->right);
        }

    }
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        if(!root || (!root->left && !root->right)){
            return root;
        }
        height(root);

        return dfs(root);

    }
};