Given the root of a binary tree, invert the tree, and return its root.
Example 1:
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
Example 2:


Input: root = [2,1,3]
Output: [2,3,1]
Example 3:

Input: root = []
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100

Solution(#1) Recursion T.c =>O(n),S.c=>O(h), h->height of the tree

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL ){
            return root;
        }
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right); 
        
    return root;
    }
};


Solution(#2)=> using Queue T.c =>O(n),S.c=>O(h)

Algorithm:
If the tree is empty, return null.
Initialize a queue and insert the root node.
While the queue is not empty:
Remove the front node.
Swap its left and right children.
If the left child exists, add it to the queue.
If the right child exists, add it to the queue.
After all nodes are processed, return the root as the inverted tree.

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL ){
            return root;
        }
        queue<TreeNode*>q;
        q.push(root);
        while(!q.empty()){
            TreeNode*front = q.front();
            q.pop();
            swap(front->left,front->right);
            if(front->left) q.push(front->left);
            if(front->right) q.push(front->right);
        }
        return root;


        
        
    return root;
    }
};