Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.

Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return the minimum integer k such that she can eat all the bananas within h hours.

 

Example 1:

Input: piles = [3,6,7,11], h = 8
Output: 4
Example 2:

Input: piles = [30,11,23,4,20], h = 5
Output: 30
Example 3:

Input: piles = [30,11,23,4,20], h = 6
Output: 23
 

Constraints:

1 <= piles.length <= 104
piles.length <= h <= 109
1 <= piles[i] <= 109


Solution(#Binary search)

Intution:
#1 The upper bound for k is the maximum size of all the piles. Why? Because if Koko eats the largest pile in one hour,
 then it is straightforward that she can eat any other pile in an hour only.
#2 he upper bound of k is max(piles) and since we are only dealing with positive values, the lower bound is 1.
 The search space of our binary search is 1 through max(piles).
 This allows us to find the smallest possible k using binary search.

class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        long long minVal = 1, maxVal = 0,psol = INT_MAX;
        if(piles.size()==1){
            if(piles[0]%h == 0){
            return piles[0]/h ;
            }
            else if(piles[0]%h==1){
                return piles[0]/h +1;
            }
        }
        for(int x: piles){
            if(x>maxVal){
                maxVal = x;
            }
        }
        
        while(minVal<=maxVal){
            long long count=0;
            long long mid = minVal+(maxVal-minVal)/2;
            for(int i=0;i<piles.size();i++){
                if(piles[i]<=mid){
                    count++;
                }
                else{
                    int rem = piles[i]%mid;
                    int q = piles[i]/mid;
                    if(rem==0){
                        count+=q;
                    }
                    else {
                        count+=(q+1);
                    }
                }
            }
            if(count<=h){
                psol= min(psol,mid); 
                maxVal=mid-1; 
            }
            else{
                minVal=mid+1;
            }
        }

        return psol;
        
        
    }
};